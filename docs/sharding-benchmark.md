# 分库分表性能压测

本文档介绍如何运行分库分表性能压测，对比单库和分库分表方案的性能差异。

## 架构设计

### 单库方案
- **数据库**: 1个 PostgreSQL 实例 (端口 5434)
- **表结构**: 1张 `orders` 表
- **数据量**: 100万订单

### 分库分表方案
- **数据库**: 8个 PostgreSQL 实例 (端口 5440-5447)
- **表结构**: 每个数据库8张表 (`orders_0` ~ `orders_7`)，共 64 个物理分片
- **分片规则**:
  - 按订单ID分片: `db_index = (order_id >> 8) % 8`, `table_index = order_id % 8`
  - 按用户ID路由: `db_index = user_id % 8`
- **数据量**: 100万订单，均匀分布到64个分片

## 压测场景

### 1. 插入订单 (Insert)
- **数据量**: 100万订单 (10万用户，每用户10个订单)
- **并发数**: 100
- **测试指标**: QPS、延迟分布

### 2. 按订单ID查询 (GetByOrderID)
- **查询模式**: 随机查询订单ID
- **并发数**: 100
- **测试时长**: 30秒
- **测试指标**: QPS、P50/P95/P99延迟

### 3. 按用户ID查询 (GetByUserID)
- **查询模式**: 随机查询用户的最近20个订单
- **并发数**: 100
- **测试时长**: 30秒
- **测试指标**: QPS、P50/P95/P99延迟

## 快速开始

### 前置条件

- Docker & Docker Compose
- Go 1.23+

### 步骤1: 启动数据库

```bash
# 启动所有数据库实例（1个单库 + 8个分片库）
docker-compose up -d postgres shard_db_0 shard_db_1 shard_db_2 shard_db_3 shard_db_4 shard_db_5 shard_db_6 shard_db_7

# 查看数据库状态
docker-compose ps

# 等待数据库启动完成（约10秒）
sleep 10
```

### 步骤2: 运行压测

```bash
# 编译并运行压测程序
go run cmd/shardbench/main.go
```

或者使用 Makefile:

```bash
make bench-sharding
```

### 步骤3: 查看结果

压测程序会输出详细的性能对比报告，包括：

- 单库 vs 分库分表的 QPS 对比
- 延迟分布 (P50/P95/P99)
- 性能提升百分比

示例输出：

```
===== 分库分表性能压测 =====
用户数: 100000
每用户订单数: 10
总订单数: 1000000
压测时长: 30秒
并发数: 100

>>> 准备单库环境...
单库环境准备完成

>>> 准备分库分表环境...
分库分表环境准备完成

>>> 生成测试数据...
生成了 1000000 个测试订单

===== 单库压测 - 插入订单 =====
名称: 单库
耗时: 45.2s
总请求数: 1000000
成功请求: 1000000
失败请求: 0
QPS: 22123.89
平均延迟: 4.52ms
P50 延迟: 3.21ms
P95 延迟: 8.45ms
P99 延迟: 12.34ms

===== 分库分表压测 - 插入订单 =====
名称: 分库分表
耗时: 18.5s
总请求数: 1000000
成功请求: 1000000
失败请求: 0
QPS: 54054.05
平均延迟: 1.85ms
P50 延迟: 1.42ms
P95 延迟: 3.67ms
P99 延迟: 5.23ms

===== 性能对比总结 =====

--- 插入订单 ---
单库 QPS: 22123.89
分库 QPS: 54054.05
性能提升: 144.24%
单库 P95: 8.45ms
分库 P95: 3.67ms
✅ 分库分表方案更优

--- 按订单ID查询 ---
单库 QPS: 15234.56
分库 QPS: 48765.43
性能提升: 220.12%
单库 P95: 6.78ms
分库 P95: 2.12ms
✅ 分库分表方案更优

--- 按用户ID查询 ---
单库 QPS: 8934.21
分库 QPS: 12456.78
性能提升: 39.45%
单库 P95: 11.23ms
分库 P95: 8.45ms
✅ 分库分表方案更优
```

## 性能分析

### 为什么分库分表性能更好？

#### 1. 写入性能提升 (2-3倍)
- **并发写入**: 8个数据库可以并行处理写入请求
- **锁竞争减少**: 数据分散到64个物理表，减少表锁和行锁竞争
- **IO分散**: 8个数据库的IO操作可以并行执行

#### 2. 查询性能提升 (2-5倍)
- **精确路由** (GetByOrderID): 直接定位到一个分片，避免全表扫描
- **并发查询** (GetByUserID): 同一个库的8张表可以并发查询
- **索引效率**: 小表的索引深度更小，查询更快

#### 3. 资源利用
- **CPU**: 多个数据库可以充分利用多核CPU
- **内存**: 每个数据库的 buffer pool 更小，缓存命中率更高
- **磁盘**: 分散到多个磁盘，减少IO瓶颈

### 什么时候单库性能更好？

在以下场景下，单库可能性能更好：

1. **小数据量** (< 500万): 分库分表的开销大于收益
2. **无热点数据**: 数据访问均匀，单库瓶颈不明显
3. **复杂查询**: 跨片查询需要应用层聚合，增加延迟
4. **低并发**: 并发数 < 100，单库已经足够

## 自定义压测参数

可以修改 `cmd/shardbench/main.go` 中的常量来调整压测参数：

```go
const (
    UserCount       = 100000  // 用户数
    OrdersPerUser   = 10      // 每用户订单数
    BenchDuration   = 30      // 压测时长（秒）
    ConcurrentLevel = 100     // 并发数
)
```

## 清理环境

```bash
# 停止并删除所有数据库容器
docker-compose down -v

# 删除所有数据卷（谨慎操作！）
docker volume prune -f
```

## 相关文档

- [分库分表最佳实践](../blogs/shareking-db.md)
- [数据库性能优化](./database-optimization.md)

## 故障排查

### 问题1: 数据库连接失败

```
连接分片数据库 0 失败: dial tcp [::1]:5440: connect: connection refused
```

**解决方案**:
1. 确认数据库已启动: `docker-compose ps`
2. 检查端口是否被占用: `lsof -i :5440`
3. 查看数据库日志: `docker-compose logs shard_db_0`

### 问题2: 表结构初始化失败

```
初始化分库分表表结构失败: relation "orders_0" already exists
```

**解决方案**:
```bash
# 重新创建数据库
docker-compose down -v
docker-compose up -d
```

### 问题3: QPS异常低

**可能原因**:
1. 数据库配置不够: 增加 `max_connections` 和 `shared_buffers`
2. 连接池太小: 调整 `SetMaxOpenConns` 和 `SetMaxIdleConns`
3. 机器资源不足: 使用 `docker stats` 查看资源使用情况

## 进阶实验

### 实验1: 不同分片数的对比

修改 `repository/order_sharded.go` 中的 `ShardCount` 和 `TableCount`，对比不同分片策略的性能。

### 实验2: 添加读写分离

为每个分片添加从库，测试读写分离后的性能提升。

### 实验3: 数据倾斜场景

修改订单ID生成规则，模拟数据倾斜场景，观察性能影响。

### 实验4: 跨片查询性能

添加全局范围查询（如按订单金额查询），对比单库和分库的性能差异。
